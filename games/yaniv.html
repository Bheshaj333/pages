<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Yaniv - Card Game</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            color: white;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .screen {
            display: none;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            margin: 20px auto;
            max-width: 500px;
        }

        .screen.active {
            display: block;
        }
        
        .mode-toggle {
            display: flex;
            gap: 10px;
            margin-bottom: 25px;
            background: rgba(0, 0, 0, 0.2);
            padding: 5px;
            border-radius: 10px;
        }
        
        .mode-toggle button {
            flex: 1;
            padding: 12px;
            background: transparent;
            border: none;
            border-radius: 8px;
            color: rgba(255, 255, 255, 0.6);
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1em;
        }
        
        .mode-toggle button.active {
            background: #4CAF50;
            color: white;
        }
        
        .mode-content {
            display: none;
        }
        
        .mode-content.active {
            display: block;
        }

        h1 {
            font-size: 3em;
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .subtitle {
            text-align: center;
            font-size: 1.2em;
            opacity: 0.9;
            margin-bottom: 30px;
        }

        .divider {
            text-align: center;
            margin: 20px 0;
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.9em;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            font-size: 1.1em;
        }

        input[type="text"], select {
            width: 100%;
            padding: 12px;
            font-size: 1.1em;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            margin-bottom: 15px;
        }

        input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .btn {
            padding: 15px 40px;
            font-size: 1.2em;
            background: #4CAF50;
            border: none;
            border-radius: 10px;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            width: 100%;
            margin-top: 10px;
        }

        .btn:hover {
            background: #45a049;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .btn:disabled {
            background: #95a5a6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: #3498db;
        }

        .btn-secondary:hover {
            background: #2980b9;
        }

        .waiting-area {
            text-align: center;
            padding: 30px;
        }

        .room-code-display {
            font-size: 2.5em;
            background: rgba(255, 215, 0, 0.2);
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            letter-spacing: 5px;
            font-weight: bold;
        }

        .players-waiting {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .player-badge {
            background: rgba(255, 255, 255, 0.15);
            padding: 15px;
            border-radius: 10px;
            font-size: 1.2em;
        }

        .game-board {
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .opponents-area {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 15px;
        }

        .opponent-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 10px;
            border: 2px solid transparent;
        }

        .opponent-card.active {
            border-color: #4CAF50;
            box-shadow: 0 0 15px rgba(76, 175, 80, 0.5);
        }

        .center-area {
            text-align: center;
        }

        .discard-section {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .discard-pile, .my-throw-pile {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 15px;
            min-height: 150px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        .discard-pile {
            cursor: pointer;
            border: 2px solid rgba(76, 175, 80, 0.3);
        }

        .discard-pile:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(76, 175, 80, 0.6);
        }

        .my-throw-pile {
            border: 2px solid rgba(231, 76, 60, 0.3);
        }

        .pile-label {
            font-size: 0.9em;
            opacity: 0.8;
            margin-bottom: 5px;
        }

        .pile-cards {
            display: flex;
            flex-wrap: wrap;
            gap: 3px;
            justify-content: center;
        }

        .deck-pile {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 15px;
            min-height: 150px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .deck-pile:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: scale(1.05);
        }

        .info-area {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 15px;
        }

        .stat-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .my-hand {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 15px;
            margin-top: 20px;
        }

        .cards-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
            min-height: 140px;
        }

        .card {
            width: 70px;
            height: 100px;
            background: white;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }

        .card:hover {
            transform: translateY(-10px);
        }

        .card.selected {
            transform: translateY(-20px);
            box-shadow: 0 8px 16px rgba(76, 175, 80, 0.6);
            border: 3px solid #4CAF50;
        }

        .card.red {
            color: #e74c3c;
        }

        .card.black {
            color: #2c3e50;
        }

        .card.joker {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .card-back {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .card.small {
            width: 50px;
            height: 70px;
            font-size: 1.1em;
        }

        .card-value {
            font-size: 1.3em;
        }

        .card-suit {
            font-size: 1.1em;
            margin-top: -5px;
        }

        .card.small .card-value {
            font-size: 1em;
        }

        .card.small .card-suit {
            font-size: 0.8em;
        }

        .actions-area {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        .action-btn {
            padding: 12px 30px;
            font-size: 1.1em;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }

        .action-btn.throw {
            background: #3498db;
            color: white;
        }

        .action-btn.show {
            background: #f39c12;
            color: white;
        }

        .action-btn:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .action-btn:disabled {
            background: #95a5a6;
            cursor: not-allowed;
            opacity: 0.5;
        }

        .rules-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid white;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            z-index: 100;
        }

        .rules-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .leave-btn {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            background: rgba(231, 76, 60, 0.3);
            border: 2px solid #e74c3c;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            z-index: 100;
            display: none;
        }

        .leave-btn:hover {
            background: rgba(231, 76, 60, 0.5);
        }

        .leave-btn.active {
            display: block;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 40px;
            border-radius: 20px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }

        .game-over-modal {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            padding: 50px;
            border-radius: 30px;
            max-width: 700px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            animation: slideIn 0.5s ease-out;
        }

        @keyframes slideIn {
            from {
                transform: translateY(-100px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .winner-banner {
            font-size: 3em;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
        }

        .winner-name {
            font-size: 2.5em;
            color: #f39c12;
            margin-bottom: 30px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .scores-table {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin: 30px 0;
        }

        .score-row {
            display: flex;
            justify-content: space-between;
            padding: 15px 20px;
            margin: 10px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            font-size: 1.3em;
            transition: all 0.3s;
        }

        .score-row:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: scale(1.02);
        }

        .score-row.winner-row {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
            box-shadow: 0 0 20px rgba(243, 156, 18, 0.5);
            font-weight: bold;
        }

        .play-again-btn {
            padding: 20px 50px;
            font-size: 1.5em;
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            border: none;
            border-radius: 15px;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            margin-top: 20px;
            box-shadow: 0 5px 20px rgba(76, 175, 80, 0.4);
        }

        .play-again-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(76, 175, 80, 0.6);
        }

        .close-btn {
            position: absolute;
            top: 10px;
            right: 20px;
            font-size: 2em;
            cursor: pointer;
            color: white;
        }

        .message {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            text-align: center;
            font-weight: bold;
        }

        .error {
            background: rgba(231, 76, 60, 0.3);
            border: 2px solid #e74c3c;
        }

        .success {
            background: rgba(76, 175, 80, 0.3);
            border: 2px solid #4CAF50;
        }

        .turn-indicator {
            background: rgba(76, 175, 80, 0.3);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            font-size: 1.3em;
            margin-bottom: 20px;
            font-weight: bold;
        }

        .confirm-modal {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 40px;
            border-radius: 20px;
            max-width: 500px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        .confirm-modal h2 {
            color: #fff;
            margin-bottom: 20px;
            font-size: 2em;
        }

        .confirm-modal p {
            color: rgba(255, 255, 255, 0.9);
        }

        .confirm-buttons {
            display: flex;
            gap: 20px;
            margin-top: 30px;
            justify-content: center;
        }

        .confirm-btn {
            padding: 15px 40px;
            font-size: 1.2em;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        .confirm-btn.yes {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
        }

        .confirm-btn.no {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
        }

        .confirm-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }

        .abort-modal {
            background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
            padding: 50px;
            border-radius: 30px;
            max-width: 600px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            animation: slideIn 0.5s ease-out;
        }

        .abort-banner {
            font-size: 3em;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(231, 76, 60, 0.8);
        }

        .abort-message {
            font-size: 1.8em;
            color: #e74c3c;
            margin-bottom: 20px;
            font-weight: bold;
        }

        .abort-details {
            font-size: 1.2em;
            opacity: 0.9;
            margin-bottom: 30px;
            line-height: 1.6;
        }

        @media (max-width: 768px) {
            .container {
                padding: 5px;
            }

            .screen {
                padding: 15px;
                margin: 5px;
            }

            h1 {
                font-size: 2em;
            }

            .game-board {
                display: flex;
                flex-direction: column;
                gap: 15px;
            }

            .turn-indicator {
                order: 1;
                font-size: 1.1em;
                padding: 10px;
                margin-bottom: 10px;
            }

            .opponents-area {
                order: 2;
                padding: 10px;
            }

            .opponent-card {
                padding: 8px;
                margin-bottom: 5px;
                font-size: 0.9em;
            }

            .center-area {
                order: 3;
            }

            .discard-section {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 8px;
                margin-bottom: 15px;
            }

            .discard-pile, .my-throw-pile {
                padding: 10px;
                min-height: 100px;
            }

            .pile-label {
                font-size: 0.8em;
            }

            .deck-pile {
                padding: 15px;
                min-height: 100px;
            }

            .info-area {
                display: none;
            }

            .my-hand {
                order: 4;
                padding: 10px;
                margin-top: 10px;
            }

            .card {
                width: 45px;
                height: 65px;
                font-size: 1em;
            }

            .card.small {
                width: 35px;
                height: 50px;
                font-size: 0.8em;
            }

            .card-value {
                font-size: 1em;
            }

            .card-suit {
                font-size: 0.8em;
            }

            .actions-area {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 10px;
                margin-top: 15px;
            }

            .action-btn {
                padding: 12px 15px;
                font-size: 1em;
            }

            .room-code-display {
                font-size: 1.8em;
                padding: 15px;
            }

            .config-section {
                padding: 15px;
            }

            .modal-content, .game-over-modal, .confirm-modal, .abort-modal {
                margin: 20px;
                max-width: 90%;
                padding: 30px 20px;
            }

            .winner-banner, .abort-banner {
                font-size: 2em;
            }

            .winner-name, .abort-message {
                font-size: 1.5em;
            }
        }
    </style>
</head>
<body>
    <button class="rules-btn" onclick="showRules()">üìñ Rules</button>
    <button class="leave-btn" id="leaveBtn" onclick="showLeaveConfirmation()">üö™ Leave Game</button>
    
    <div class="container">
        <div id="messageArea"></div>

        <!-- Setup Screen -->
        <div class="screen active" id="setupScreen">
            <h1>üÉè Yaniv</h1>
            <p class="subtitle">Call "Show" to win with ‚â§10 points!</p>
            
            <input type="text" id="playerName" placeholder="Enter your name">
            
            <div class="mode-toggle">
                <button class="active" id="offlineBtn" onclick="switchMode('offline')">ü§ñ Offline</button>
                <button id="onlineBtn" onclick="switchMode('online')">üåê Online</button>
            </div>
            
            <!-- Offline Mode -->
            <div id="offlineMode" class="mode-content active">
                <button class="btn" onclick="startOfflineGame()">üéÆ Play vs Bot</button>
            </div>
            
            <!-- Online Mode -->
            <div id="onlineMode" class="mode-content">
                <select id="numPlayers">
                    <option value="2">2 Players</option>
                    <option value="3">3 Players</option>
                    <option value="4">4 Players</option>
                </select>
                
                <button class="btn btn-secondary" onclick="createGame()">üé≤ Create Game</button>
                
                <div class="divider">OR</div>
                
                <input type="text" id="roomCode" placeholder="Enter room code">
                <button class="btn btn-secondary" onclick="joinGame()" id="joinBtn">üö™ Join Game</button>
            </div>
        </div>

        <!-- Waiting Room -->
        <div class="screen" id="waitingScreen">
            <div class="waiting-area">
                <h1>‚è≥ Waiting for Players</h1>
                <div class="room-code-display" id="displayRoomCode"></div>
                <p style="font-size: 1.2em; margin-bottom: 20px;">Share this code with your friends!</p>
                
                <div class="players-waiting" id="playersWaiting"></div>
                
                <button class="btn" id="startGameBtn" onclick="startGame()" style="max-width: 400px; margin: 20px auto;">
                    üöÄ Start Game
                </button>
            </div>
        </div>

        <!-- Game Screen -->
        <div class="screen" id="gameScreen" style="max-width: 1400px;">
            <div id="turnIndicator" class="turn-indicator"></div>
            
            <div class="game-board">
                <div class="opponents-area" id="opponentsArea"></div>
                
                <div class="center-area">
                    <div class="discard-section">
                        <div class="discard-pile" onclick="drawFromDiscard()">
                            <div class="pile-label">‚¨ÜÔ∏è Opponent's Cards (Click to pick)</div>
                            <div class="pile-cards" id="opponentDiscardPile"></div>
                        </div>
                        <div class="my-throw-pile">
                            <div class="pile-label">üéØ Your Thrown Cards</div>
                            <div class="pile-cards" id="myThrowPile"></div>
                        </div>
                    </div>
                    
                    <h3>Draw Deck</h3>
                    <div class="deck-pile" onclick="drawCard()">
                        <div class="card card-back">
                            <div>üÇ†</div>
                            <div style="font-size: 0.6em; margin-top: 5px;">Draw</div>
                        </div>
                    </div>
                </div>
                
                <div class="info-area">
                    <h3 style="margin-bottom: 15px;">Game Info</h3>
                    <div class="stat-item">
                        üë§ <span id="currentPlayerName">Player</span>
                    </div>
                    <div class="stat-item">
                        üéØ Hand Value: <span id="handValue">0</span>
                    </div>
                    <div class="stat-item">
                        üÉè Cards: <span id="cardsCount">0</span>
                    </div>
                    <div class="stat-item">
                        üìä Deck: <span id="deckCount">0</span>
                    </div>
                </div>
            </div>
            
            <div class="my-hand">
                <h2 style="text-align: center; margin-bottom: 15px;">Your Hand</h2>
                <div class="cards-container" id="myHand"></div>
                
                <div class="actions-area">
                    <button class="action-btn throw" onclick="throwCards()" id="throwBtn">
                        üéØ Throw Selected Cards
                    </button>
                    <button class="action-btn show" onclick="callShow()" id="showBtn">
                        üèÜ Call SHOW!
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Confirm Leave Modal -->
    <div class="modal" id="confirmLeaveModal">
        <div class="confirm-modal">
            <h2 style="margin-bottom: 20px;">‚ö†Ô∏è Leave Game?</h2>
            <p style="font-size: 1.2em;">Are you sure you want to leave the game?</p>
            <p style="font-size: 1em; opacity: 0.8; margin-top: 10px;">You won't be able to rejoin this match.</p>
            <div class="confirm-buttons">
                <button class="confirm-btn yes" onclick="confirmLeaveGame()">Yes, Leave</button>
                <button class="confirm-btn no" onclick="cancelLeaveGame()">Stay in Game</button>
            </div>
        </div>
    </div>

    <!-- Reveal Cards Modal -->
    <div class="modal" id="revealModal">
        <div class="game-over-modal">
            <h2 style="font-size: 2.5em; margin-bottom: 30px;">üìã All Hands Revealed</h2>
            <div id="revealedHands"></div>
            <button class="play-again-btn" onclick="showFinalResults()">Continue ‚Üí</button>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div class="modal" id="gameOverModal">
        <div class="game-over-modal">
            <div class="winner-banner">üèÜ GAME OVER üèÜ</div>
            <div class="winner-name" id="winnerName"></div>
            <div class="scores-table" id="finalScores"></div>
            <button class="play-again-btn" onclick="location.reload()">üéÆ Play Again</button>
        </div>
    </div>

    <!-- Match Aborted Modal -->
    <div class="modal" id="matchAbortedModal">
        <div class="abort-modal">
            <div class="abort-banner">‚ö†Ô∏è MATCH ABORTED </div>
            <div class="abort-message">A player has left the game</div>
            <div class="abort-details">
                <p><strong id="leftPlayerName"></strong> has disconnected from the match.</p>
                <p>The game cannot continue and has been terminated.</p>
            </div>
            <button class="play-again-btn" onclick="location.reload()">üéÆ New Game</button>
        </div>
    </div>

    <!-- Rules Modal -->
    <div class="modal" id="rulesModal">
        <div class="modal-content">
            <span class="close-btn" onclick="closeRules()">&times;</span>
            <div>
                <h2>How to Play Yaniv</h2>
                <h3 style="margin-top: 20px;">Objective:</h3>
                <p>Be the first to call "SHOW" with a hand value of 10 or less!</p>
                
                <h3 style="margin-top: 20px;">Card Values:</h3>
                <ul style="margin-left: 20px; line-height: 1.8;">
                    <li>Ace = 1 point</li>
                    <li>2-10 = Face value</li>
                    <li>J, Q, K = 10 points each</li>
                    <li>Joker = 0 points</li>
                </ul>
                
                <h3 style="margin-top: 20px;">Gameplay:</h3>
                <ul style="margin-left: 20px; line-height: 1.8;">
                    <li>Start with 7 cards</li>
                    <li>On your turn: Throw valid cards, then draw one</li>
                    <li><strong>Valid Throws:</strong></li>
                    <li>- Single card</li>
                    <li>- Pairs/Sets: 2+ cards of same rank (7-7 or 7-7-7)</li>
                    <li>- Runs: 3+ consecutive cards of same suit (3‚ô•-4‚ô•-5‚ô•)</li>
                    <li>Draw from deck OR pick opponent's last card from discard pile</li>
                    <li>Call "SHOW" when you have ‚â§10 points</li>
                    <li>Everyone reveals - lowest hand wins!</li>
                </ul>
                
                <h3 style="margin-top: 20px;">Tips:</h3>
                <ul style="margin-left: 20px; line-height: 1.8;">
                    <li>Keep Aces and low cards</li>
                    <li>Get rid of face cards quickly</li>
                    <li>Watch what others discard</li>
                    <li>You can call SHOW even with more than 3 cards if total ‚â§10</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // Hardcoded Supabase credentials
        const SUPABASE_URL = 'https://tkdxculbojbfpckwtfpx.supabase.co';
        const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRrZHhjdWxib2piZnBja3d0ZnB4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjEzOTc0MDUsImV4cCI6MjA3Njk3MzQwNX0.TFvv15rgzjNRIj0oQhzsyjXCuYDzA1Uzo8hFLUaf7Vg';
        
        let supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
        let gameId;
        let playerId;
        let playerIndex;
        let playerName;
        let myHand = [];
        let selectedCards = [];
        let gameState = {};
        let allPlayers = [];
        let realtimeChannel;
        let hasThrown = false;
        let isCreator = false;
        let myThrownCards = [];
        let opponentDiscardCards = [];
        let isJoining = false;
        let waitingRoomInterval = null;
        let isOfflineMode = false;
        let botHand = [];
        let botThinkingTimeout = null;

        const suits = ['‚ô†', '‚ô•', '‚ô¶', '‚ô£'];
        const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
        const botNames = ['Pappu', 'Bablu', 'Chintu', 'Bunty', 'Guddu', 'Munna', 'Raju', 'Shyam', 'Golu', 'Tinku'];
        
        function switchMode(mode) {
            const offlineBtn = document.getElementById('offlineBtn');
            const onlineBtn = document.getElementById('onlineBtn');
            const offlineMode = document.getElementById('offlineMode');
            const onlineMode = document.getElementById('onlineMode');
            
            if (mode === 'offline') {
                offlineBtn.classList.add('active');
                onlineBtn.classList.remove('active');
                offlineMode.classList.add('active');
                onlineMode.classList.remove('active');
            } else {
                onlineBtn.classList.add('active');
                offlineBtn.classList.remove('active');
                onlineMode.classList.add('active');
                offlineMode.classList.remove('active');
            }
        }
        
        function startOfflineGame() {
            playerName = document.getElementById('playerName').value.trim();
            if (!playerName) {
                showMessage('Please enter your name', 'error');
                return;
            }
            
            isOfflineMode = true;
            const deck = createDeck();
            const botName = botNames[Math.floor(Math.random() * botNames.length)];
            
            // Deal cards
            myHand = [];
            botHand = [];
            for (let i = 0; i < 7; i++) {
                myHand.push(deck.pop());
                botHand.push(deck.pop());
            }
            
            gameState = {
                deck: deck,
                discard_pile: [deck.pop()],
                current_player: 0
            };
            
            allPlayers = [
                { id: 'player', player_name: playerName, hand: myHand, player_index: 0 },
                { id: 'bot', player_name: botName, hand: botHand, player_index: 1 }
            ];
            
            playerId = 'player';
            hasThrown = false;
            myThrownCards = [];
            
            showScreen('gameScreen');
            renderGame();
        }

        // Prevent back navigation and show confirmation
        let isInGame = false;

        window.addEventListener('load', () => {
            history.pushState(null, '', location.href);
            restoreGameState();
        });

        window.addEventListener('popstate', (e) => {
            if (isInGame) {
                e.preventDefault();
                history.pushState(null, '', location.href);
                showLeaveConfirmation();
            }
        });

        window.addEventListener('beforeunload', (e) => {
            if (isInGame) {
                e.preventDefault();
                e.returnValue = '';
                return '';
            }
        });

        function showLeaveConfirmation() {
            document.getElementById('confirmLeaveModal').classList.add('active');
        }

        function confirmLeaveGame() {
            isInGame = false;
            localStorage.removeItem('yanivGameState');
            document.getElementById('confirmLeaveModal').classList.remove('active');
            
            // Notify other players by deleting this player and marking game as aborted
            notifyGameAborted();
            
            // Clean up realtime subscription
            if (realtimeChannel) {
                realtimeChannel.unsubscribe();
            }
            
            // Reset all game variables
            gameId = null;
            playerId = null;
            playerIndex = null;
            playerName = null;
            myHand = [];
            selectedCards = [];
            gameState = {};
            allPlayers = [];
            hasThrown = false;
            isCreator = false;
            myThrownCards = [];
            opponentDiscardCards = [];
            
            // Hide leave button
            document.getElementById('leaveBtn').classList.remove('active');
            
            // Show success message and go back to setup
            showScreen('setupScreen');
            showMessage('You have left the game', 'success');
        }

        async function notifyGameAborted() {
            try {
                const currentScreen = document.querySelector('.screen.active').id;
                
                if (currentScreen === 'waitingScreen') {
                    // Just remove player from lobby - triggers real-time update
                    console.log("Here")
                    console.log("playerId : " +playerId);
                    await supabase
                        .from('yaniv_players')
                        .delete()
                        .eq('id', playerId);
                } else if (currentScreen === 'gameScreen') {
                    // Mark game as aborted and remove player
                    await supabase
                        .from('yaniv_games')
                        .update({ 
                            status: 'aborted',
                            winner_name: playerName // Store who left in winner_name field
                        })
                        .eq('id', gameId);
                }
            } catch (error) {
                console.error('Error notifying game abort:', error);
            }
        }

        function cancelLeaveGame() {
            document.getElementById('confirmLeaveModal').classList.remove('active');
        }

        // Save game state to localStorage
        function saveGameState() {
            const state = {
                gameId,
                playerId,
                playerIndex,
                playerName,
                isCreator,
                timestamp: Date.now()
            };
            localStorage.setItem('yanivGameState', JSON.stringify(state));
        }

        // Restore game state from localStorage
        async function restoreGameState() {
            const saved = localStorage.getItem('yanivGameState');
            if (!saved) return;

            try {
                const state = JSON.parse(saved);
                
                // Check if state is recent (within 1 hour)
                if (Date.now() - state.timestamp > 3600000) {
                    localStorage.removeItem('yanivGameState');
                    return;
                }

                gameId = state.gameId;
                playerId = state.playerId;
                playerIndex = state.playerIndex;
                playerName = state.playerName;
                isCreator = state.isCreator;

                // Check if game still exists
                const { data: game } = await supabase
                    .from('yaniv_games')
                    .select('*')
                    .eq('id', gameId)
                    .single();

                if (!game) {
                    localStorage.removeItem('yanivGameState');
                    return;
                }

                isInGame = true;
                setupRealtimeSubscription();

                if (game.status === 'waiting') {
                    document.getElementById('leaveBtn').classList.add('active');
                    showScreen('waitingScreen');
                    document.getElementById('displayRoomCode').textContent = game.room_code;
                    updateWaitingRoom();
                } else if (game.status === 'playing') {
                    document.getElementById('leaveBtn').classList.add('active');
                    showScreen('gameScreen');
                    loadGameState();
                }
            } catch (error) {
                console.error('Error restoring game state:', error);
                localStorage.removeItem('yanivGameState');
            }
        }

        function generateRoomCode() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }

        function createDeck() {
            const deck = [];
            for (let suit of suits) {
                for (let rank of ranks) {
                    deck.push({ rank, suit });
                }
            }
            deck.push({ rank: 'JOKER', suit: 'üÉè' });
            deck.push({ rank: 'JOKER', suit: 'üÉè' });
            
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            return deck;
        }

        async function createGame() {
            playerName = document.getElementById('playerName').value.trim();
            
            if (!playerName) {
                showMessage('Please enter your name', 'error');
                return;
            }
            
            const roomCode = generateRoomCode();
            const deck = createDeck();
            
            try {
                const { data: game, error: gameError } = await supabase
                    .from('yaniv_games')
                    .insert({
                        room_code: roomCode,
                        status: 'waiting',
                        deck: deck,
                        discard_pile: [],
                        current_player: 0
                    })
                    .select()
                    .single();
                
                if (gameError) throw gameError;
                
                gameId = game.id;
                playerIndex = 0;
                isCreator = true;
                
                const { data: player, error: playerError } = await supabase
                    .from('yaniv_players')
                    .insert({
                        game_id: gameId,
                        player_name: playerName,
                        player_index: 0,
                        hand: [],
                        score: 0
                    })
                    .select()
                    .single();
                
                if (playerError) throw playerError;
                
                playerId = player.id;
                isInGame = true;

                document.getElementById('displayRoomCode').textContent = roomCode;
                document.getElementById('leaveBtn').classList.add('active');
                showScreen('waitingScreen');
                setupRealtimeSubscription();
                updateWaitingRoom();
                startWaitingRoomPolling();
                saveGameState();
            } catch (error) {
                showMessage('Failed to create game: ' + error.message, 'error');
            }
        }

        async function joinGame() {
            if (isJoining) return;
            isJoining = true;
            
            const joinBtn = document.getElementById('joinBtn');
            joinBtn.disabled = true;
            
            playerName = document.getElementById('playerName').value.trim();
            const roomCode = document.getElementById('roomCode').value.trim().toUpperCase();
            
            if (!playerName || !roomCode) {
                showMessage('Please enter your name and room code', 'error');
                isJoining = false;
                joinBtn.disabled = false;
                return;
            }
            
            try {
                const { data: games, error: gameError } = await supabase
                    .from('yaniv_games')
                    .select('*')
                    .eq('room_code', roomCode)
                    .eq('status', 'waiting')
                    .single();
                
                if (gameError) throw new Error('Game not found or already started');
                
                const { data: existingPlayers } = await supabase
                    .from('yaniv_players')
                    .select('*')
                    .eq('game_id', games.id);
                
                if (existingPlayers.length >= 4) {
                    throw new Error('Game is full');
                }
                
                gameId = games.id;
                playerIndex = existingPlayers.length;
                
                const { data: player, error: playerError } = await supabase
                    .from('yaniv_players')
                    .insert({
                        game_id: gameId,
                        player_name: playerName,
                        player_index: playerIndex,
                        hand: [],
                        score: 0
                    })
                    .select()
                    .single();
                
                if (playerError) throw playerError;
                
                playerId = player.id;
                isInGame = true;

                document.getElementById('displayRoomCode').textContent = roomCode;
                document.getElementById('leaveBtn').classList.add('active');
                showScreen('waitingScreen');
                setupRealtimeSubscription();
                updateWaitingRoom();
                startWaitingRoomPolling();
                saveGameState();
            } catch (error) {
                showMessage('Failed to join game: ' + error.message, 'error');
            } finally {
                isJoining = false;
                joinBtn.disabled = false;
            }
        }

        async function updateWaitingRoom() {
            try {
                const { data: players } = await supabase
                    .from('yaniv_players')
                    .select('*')
                    .eq('game_id', gameId)
                    .order('player_index');
                
                const container = document.getElementById('playersWaiting');
                container.innerHTML = players.map(p => 
                    `<div class="player-badge">üë§ ${p.player_name}</div>`
                ).join('');
                
                const startBtn = document.getElementById('startGameBtn');
                startBtn.disabled = players.length < 2 || players[0].id !== playerId;
            } catch (error) {
                console.error('Error updating waiting room:', error);
            }
        }

        async function startGame() {
            try {
                const { data: players } = await supabase
                    .from('yaniv_players')
                    .select('*')
                    .eq('game_id', gameId)
                    .order('player_index');
                
                if (players.length < 2) {
                    showMessage('Need at least 2 players to start', 'error');
                    return;
                }
                
                const { data: game } = await supabase
                    .from('yaniv_games')
                    .select('deck')
                    .eq('id', gameId)
                    .single();
                
                let deck = [...game.deck];
                
                for (let player of players) {
                    const hand = [];
                    for (let i = 0; i < 7; i++) {
                        hand.push(deck.pop());
                    }
                    
                    await supabase
                        .from('yaniv_players')
                        .update({ hand: hand })
                        .eq('id', player.id);
                }
                
                const discardPile = [deck.pop()];
                
                await supabase
                    .from('yaniv_games')
                    .update({
                        status: 'playing',
                        deck: deck,
                        discard_pile: discardPile,
                        current_player: 0
                    })
                    .eq('id', gameId);
                
            } catch (error) {
                showMessage('Failed to start game: ' + error.message, 'error');
            }
        }

        function setupRealtimeSubscription() {
            realtimeChannel = supabase
                .channel('game-changes')
                .on('postgres_changes',
                    { event: '*', schema: 'public', table: 'yaniv_games', filter: `id=eq.${gameId}` },
                    handleGameUpdate
                )
                .on('postgres_changes',
                    { event: '*', schema: 'public', table: 'yaniv_players', filter: `game_id=eq.${gameId}` },
                    handlePlayerUpdate
                )
                .subscribe();
        }

        function handleGameUpdate(payload) {
            if (payload.new.status === 'playing') {
                loadGameState();
            } else if (payload.new.status === 'finished') {
                showGameResult();
            } else if (payload.new.status === 'aborted') {
                // Only show abort modal if we're currently in game screen
                const currentScreen = document.querySelector('.screen.active').id;
                if (currentScreen === 'gameScreen') {
                    showMatchAborted(payload.new.winner_name);
                }
            } else {
                updateWaitingRoom();
            }
        }

        function handlePlayerUpdate(payload) {
            const currentScreen = document.querySelector('.screen.active').id;
            if (currentScreen === 'waitingScreen') {
                updateWaitingRoom();
            } else if (currentScreen === 'gameScreen') {
                loadGameState();
            }
        }

        async function loadGameState() {
            try {
                const { data: game } = await supabase
                    .from('yaniv_games')
                    .select('*')
                    .eq('id', gameId)
                    .single();
                
                const { data: players } = await supabase
                    .from('yaniv_players')
                    .select('*')
                    .eq('game_id', gameId)
                    .order('player_index');
                
                gameState = game;
                allPlayers = players;
                
                const myPlayer = players.find(p => p.id === playerId);
                myHand = myPlayer.hand || [];
                
                showScreen('gameScreen');
                renderGame();
            } catch (error) {
                console.error('Error loading game state:', error);
            }
        }

        function renderGame() {
            const currentPlayer = allPlayers[gameState.current_player];
            const isMyTurn = currentPlayer.id === playerId;
            
            // Bot turn in offline mode
            if (isOfflineMode && !isMyTurn && currentPlayer.id === 'bot') {
                setTimeout(() => {
                    botTurn();
                }, 1500);
            }
            
            if (!isMyTurn) {
                selectedCards = [];
            }
            
            // Render my hand
            document.getElementById('myHand').innerHTML = myHand.map((card, idx) => 
                renderCard(card, idx, false)
            ).join('');
            
            // Handle discard pile display
            const totalDiscard = gameState.discard_pile || [];
            
            // Show my thrown cards
            if (hasThrown && myThrownCards.length > 0) {
                document.getElementById('myThrowPile').innerHTML = myThrownCards.map(card => 
                    renderCard(card, undefined, true)
                ).join('');
            } else {
                document.getElementById('myThrowPile').innerHTML = '<p style="opacity: 0.5; font-size: 0.9em;">No cards thrown yet</p>';
            }
            
            // Show opponent's cards (exclude my current thrown cards)
            let opponentCards = [];
            if (hasThrown && myThrownCards.length > 0) {
                opponentCards = totalDiscard.slice(0, -myThrownCards.length);
            } else {
                opponentCards = totalDiscard;
            }
            
            if (opponentCards.length > 0) {
                const displayCards = opponentCards.slice(-5);
                document.getElementById('opponentDiscardPile').innerHTML = displayCards.map(card => 
                    renderCard(card, undefined, true)
                ).join('');
            } else {
                document.getElementById('opponentDiscardPile').innerHTML = '<p style="opacity: 0.5; font-size: 0.9em;">Empty</p>';
            }
            
            document.getElementById('turnIndicator').textContent = isMyTurn 
                ? 'üéØ YOUR TURN!' 
                : `‚è≥ Waiting for ${currentPlayer.player_name}...`;
            
            document.getElementById('currentPlayerName').textContent = playerName;
            document.getElementById('handValue').textContent = calculateHandValue(myHand);
            document.getElementById('cardsCount').textContent = myHand.length;
            document.getElementById('deckCount').textContent = gameState.deck.length;
            
            const opponentsHtml = allPlayers
                .filter(p => p.id !== playerId)
                .map(p => `
                    <div class="opponent-card ${p.player_index === gameState.current_player ? 'active' : ''}">
                        <div style="font-weight: bold; margin-bottom: 5px;">${p.player_name}</div>
                        <div>üÉè ${p.hand.length} cards</div>
                    </div>
                `).join('');
            
            document.getElementById('opponentsArea').innerHTML = opponentsHtml;
            
            const handValue = calculateHandValue(myHand);
            document.getElementById('showBtn').disabled = !isMyTurn || handValue > 10 || hasThrown;
            document.getElementById('throwBtn').disabled = !isMyTurn || selectedCards.length === 0 || hasThrown;
        }

        function renderCard(card, index, isSmall = false) {
            const isRed = card.suit === '‚ô•' || card.suit === '‚ô¶';
            const isJoker = card.rank === 'JOKER';
            const isSelected = index !== undefined && selectedCards.includes(index);
            
            return `
                <div class="card ${isSmall ? 'small' : ''} ${isJoker ? 'joker' : (isRed ? 'red' : 'black')} ${isSelected ? 'selected' : ''}" 
                     ${index !== undefined ? `onclick="toggleCardSelection(${index})"` : ''}>
                    <div class="card-value">${card.rank}</div>
                    <div class="card-suit">${card.suit}</div>
                </div>
            `;
        }

        function toggleCardSelection(index) {
            const currentPlayer = allPlayers[gameState.current_player];
            if (currentPlayer.id !== playerId) {
                showMessage('Not your turn!', 'error');
                return;
            }
            
            const cardIndex = selectedCards.indexOf(index);
            if (cardIndex > -1) {
                selectedCards.splice(cardIndex, 1);
            } else {
                selectedCards.push(index);
            }
            renderGame();
        }

        function calculateHandValue(hand) {
            return hand.reduce((sum, card) => {
                if (card.rank === 'JOKER') return sum;
                if (card.rank === 'A') return sum + 1;
                if (['J', 'Q', 'K'].includes(card.rank)) return sum + 10;
                return sum + parseInt(card.rank);
            }, 0);
        }

        function isValidThrow(cards) {
            if (cards.length === 1) return true;
            
            if (cards.length === 2) {
                return cards[0].rank === cards[1].rank;
            }
            
            const ranks = cards.map(c => c.rank);
            const suits = cards.map(c => c.suit);
            
            const allSameRank = ranks.every(r => r === ranks[0]);
            if (allSameRank) return true;
            
            if (suits.every(s => s === suits[0])) {
                const rankValues = cards.map(c => {
                    const idx = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'].indexOf(c.rank);
                    return idx;
                }).sort((a, b) => a - b);
                
                for (let i = 1; i < rankValues.length; i++) {
                    if (rankValues[i] !== rankValues[i-1] + 1) return false;
                }
                return true;
            }
            
            return false;
        }

        async function throwCards() {
            const currentPlayer = allPlayers[gameState.current_player];
            if (currentPlayer.id !== playerId) {
                showMessage('Not your turn!', 'error');
                return;
            }
            
            if (hasThrown) {
                showMessage('You already threw cards. Now draw a card!', 'error');
                return;
            }
            
            if (selectedCards.length === 0) {
                showMessage('Select cards to throw', 'error');
                return;
            }
            
            const cardsToThrow = selectedCards.map(i => myHand[i]);
            
            if (!isValidThrow(cardsToThrow)) {
                showMessage('Invalid throw! Must be single, pair/set, or run of 3+', 'error');
                return;
            }
            
            if (isOfflineMode) {
                offlineThrowCards(cardsToThrow);
                return;
            }
            
            try {
                const { data: latestGame } = await supabase
                    .from('yaniv_games')
                    .select('discard_pile')
                    .eq('id', gameId)
                    .single();
                
                const newHand = myHand.filter((_, i) => !selectedCards.includes(i));
                const newDiscard = [...latestGame.discard_pile, ...cardsToThrow];
                
                await supabase
                    .from('yaniv_players')
                    .update({ hand: newHand })
                    .eq('id', playerId);
                
                await supabase
                    .from('yaniv_games')
                    .update({ discard_pile: newDiscard })
                    .eq('id', gameId);
                
                myHand = newHand;
                gameState.discard_pile = newDiscard;
                hasThrown = true;
                myThrownCards = cardsToThrow;
                selectedCards = [];
                
                showMessage('Cards thrown! Now draw a card.', 'success');
                renderGame();
            } catch (error) {
                showMessage('Failed to throw cards: ' + error.message, 'error');
            }
        }
        
        function offlineThrowCards(cardsToThrow) {
            const newHand = myHand.filter((_, i) => !selectedCards.includes(i));
            gameState.discard_pile.push(...cardsToThrow);
            
            myHand = newHand;
            allPlayers[0].hand = myHand;
            hasThrown = true;
            myThrownCards = cardsToThrow;
            selectedCards = [];
            
            showMessage('Cards thrown! Now draw a card.', 'success');
            renderGame();
        }

        async function drawCard() {
            const currentPlayer = allPlayers[gameState.current_player];
            if (currentPlayer.id !== playerId) {
                showMessage('Not your turn!', 'error');
                return;
            }
            
            if (!hasThrown) {
                showMessage('Throw cards first!', 'error');
                return;
            }
            
            if (isOfflineMode) {
                offlineDrawCard();
                return;
            }
            
            try {
                const newDeck = [...gameState.deck];
                if (newDeck.length === 0) {
                    showMessage('Deck is empty!', 'error');
                    return;
                }
                
                const drawnCard = newDeck.pop();
                const newHand = [...myHand, drawnCard];
                
                const nextPlayer = (gameState.current_player + 1) % allPlayers.length;
                
                await supabase
                    .from('yaniv_players')
                    .update({ hand: newHand })
                    .eq('id', playerId);
                
                await supabase
                    .from('yaniv_games')
                    .update({ 
                        deck: newDeck,
                        current_player: nextPlayer
                    })
                    .eq('id', gameId);
                
                myHand = newHand;
                hasThrown = false;
                myThrownCards = [];
                selectedCards = [];
                
            } catch (error) {
                showMessage('Failed to draw card: ' + error.message, 'error');
            }
        }
        
        function offlineDrawCard() {
            const drawnCard = gameState.deck.pop();
            myHand.push(drawnCard);
            allPlayers[0].hand = myHand;
            
            gameState.current_player = 1;
            hasThrown = false;
            myThrownCards = [];
            selectedCards = [];
            
            renderGame();
        }

        async function drawFromDiscard() {
            const currentPlayer = allPlayers[gameState.current_player];
            if (currentPlayer.id !== playerId) {
                showMessage('Not your turn!', 'error');
                return;
            }
            
            if (!hasThrown) {
                showMessage('Throw cards first!', 'error');
                return;
            }
            
            if (isOfflineMode) {
                offlineDrawFromDiscard();
                return;
            }
            
            const { data: latestGame } = await supabase
                .from('yaniv_games')
                .select('discard_pile')
                .eq('id', gameId)
                .single();
            
            if (!latestGame || latestGame.discard_pile.length === 0) {
                showMessage('Discard pile is empty!', 'error');
                return;
            }
            
            try {
                const currentDiscard = [...latestGame.discard_pile];
                
                // Remove my thrown cards to get opponent's cards
                const myThrowCount = myThrownCards.length;
                let availableCards = currentDiscard.slice(0, currentDiscard.length - myThrowCount);
                
                if (availableCards.length === 0) {
                    showMessage('No opponent cards to pick!', 'error');
                    return;
                }
                
                // Pick the last card from opponent's pile
                const drawnCard = availableCards[availableCards.length - 1];
                
                // Remove that card from the full discard pile
                const newDiscard = [...currentDiscard];
                const cardIdx = newDiscard.lastIndexOf(drawnCard);
                if (cardIdx !== -1) {
                    newDiscard.splice(cardIdx, 1);
                }
                
                const newHand = [...myHand, drawnCard];
                const nextPlayer = (gameState.current_player + 1) % allPlayers.length;
                
                await supabase
                    .from('yaniv_players')
                    .update({ hand: newHand })
                    .eq('id', playerId);
                
                await supabase
                    .from('yaniv_games')
                    .update({ 
                        discard_pile: newDiscard,
                        current_player: nextPlayer
                    })
                    .eq('id', gameId);
                
                myHand = newHand;
                hasThrown = false;
                myThrownCards = [];
                selectedCards = [];
                
            } catch (error) {
                showMessage('Failed to draw from discard: ' + error.message, 'error');
            }
        }
        
        function offlineDrawFromDiscard() {
            const availableCards = gameState.discard_pile.slice(0, -myThrownCards.length);
            
            if (availableCards.length === 0) {
                showMessage('No opponent cards to pick!', 'error');
                return;
            }
            
            const drawnCard = availableCards[availableCards.length - 1];
            const cardIdx = gameState.discard_pile.lastIndexOf(drawnCard);
            gameState.discard_pile.splice(cardIdx, 1);
            
            myHand.push(drawnCard);
            allPlayers[0].hand = myHand;
            
            gameState.current_player = 1;
            hasThrown = false;
            myThrownCards = [];
            selectedCards = [];
            
            renderGame();
        }

        async function showGameResult() {
            try {
                const { data: gameData } = await supabase
                    .from('yaniv_games')
                    .select('*')
                    .eq('id', gameId)
                    .single();
                
                if (!gameData) return;

                const { data: currentPlayers } = await supabase
                    .from('yaniv_players')
                    .select('*')
                    .eq('game_id', gameId)
                    .order('player_index');
                
                if (!currentPlayers) return;

                const playerScores = currentPlayers.map(p => ({
                    name: p.player_name,
                    value: calculateHandValue(p.hand)
                }));

                const winner = playerScores.find(p => p.name === gameData.winner_name);
                if (!winner) return;

                showGameOverModal(winner, playerScores);
            } catch (error) {
                console.error("Error in showGameResult:", error);
            }
        }

        async function callShow() {
            const currentPlayer = allPlayers[gameState.current_player];
            if (currentPlayer.id !== playerId) {
                showMessage('Not your turn!', 'error');
                return;
            }
            
            if (hasThrown) {
                showMessage('You cannot call SHOW after throwing cards. Draw a card first!', 'error');
                return;
            }
            
            const handValue = calculateHandValue(myHand);
            if (handValue > 10) {
                showMessage('Your hand value must be 10 or less to call SHOW!', 'error');
                return;
            }
            
            if (!confirm(`Call SHOW with ${myHand.length} cards totaling ${handValue} points?`)) {
                return;
            }
            
            if (isOfflineMode) {
                offlineCallShow();
                return;
            }
            
            try {
                const { data: currentPlayers } = await supabase
                    .from('yaniv_players')
                    .select('*')
                    .eq('game_id', gameId)
                    .order('player_index');
                
                const caller = currentPlayers.find(p => p.id === playerId);
                const playerScores = currentPlayers.map(p => ({
                    name: p.player_name,
                    value: calculateHandValue(p.hand),
                    isCaller: p.id === playerId
                }));
                
                const lowestScore = Math.min(...playerScores.map(p => p.value));
                const playersWithLowest = playerScores.filter(p => p.value === lowestScore);
                
                // Tie-breaker: if multiple players have lowest score, caller loses
                const winner = playersWithLowest.length > 1 && playersWithLowest.some(p => p.isCaller)
                    ? playersWithLowest.find(p => !p.isCaller)
                    : playersWithLowest[0];
                
                await supabase
                    .from('yaniv_games')
                    .update({
                        status: 'finished',
                        winner_name: winner.name
                    })
                    .eq('id', gameId);
                
                isInGame = false;
                localStorage.removeItem('yanivGameState');
                
            } catch (error) {
                showMessage('Failed to call SHOW: ' + error.message, 'error');
            }
        }
        
        function offlineCallShow() {
            const playerScores = allPlayers.map(p => ({
                name: p.player_name,
                value: calculateHandValue(p.hand),
                isCaller: p.id === playerId
            }));
            
            const lowestScore = Math.min(...playerScores.map(p => p.value));
            const playersWithLowest = playerScores.filter(p => p.value === lowestScore);
            
            // Tie-breaker: if multiple players have lowest score, caller loses
            const winner = playersWithLowest.length > 1 && playersWithLowest.some(p => p.isCaller)
                ? playersWithLowest.find(p => !p.isCaller)
                : playersWithLowest[0];
            
            showGameOverModal(winner, playerScores);
        }

        let finalWinner, finalPlayerScores;
        
        function showGameOverModal(winner, playerScores) {
            finalWinner = winner;
            finalPlayerScores = playerScores;
            
            const handsHtml = allPlayers.map(p => {
                const score = playerScores.find(ps => ps.name === p.player_name);
                return `
                    <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 15px; margin: 15px 0;">
                        <h3 style="margin-bottom: 15px;">${p.player_name} - ${score.value} points</h3>
                        <div style="display: flex; flex-wrap: wrap; gap: 8px; justify-content: center;">
                            ${p.hand.map(card => renderCard(card, undefined, true)).join('')}
                        </div>
                    </div>
                `;
            }).join('');
            
            document.getElementById('revealedHands').innerHTML = handsHtml;
            document.getElementById('revealModal').classList.add('active');
        }
        
        function showFinalResults() {
            document.getElementById('revealModal').classList.remove('active');
            
            document.getElementById('winnerName').textContent = `${finalWinner.name} Wins!`;
            
            const scoresHtml = finalPlayerScores
                .sort((a, b) => a.value - b.value)
                .map(player => `
                    <div class="score-row ${player.name === finalWinner.name ? 'winner-row' : ''}">
                        <span>${player.name === finalWinner.name ? 'üëë ' : ''}${player.name}</span>
                        <span>${player.value} points</span>
                    </div>
                `).join('');
            
            document.getElementById('finalScores').innerHTML = scoresHtml;
            document.getElementById('gameOverModal').classList.add('active');
        }

        function showMatchAborted(leftPlayerName) {
            isInGame = false;
            localStorage.removeItem('yanivGameState');
            
            document.getElementById('leftPlayerName').textContent = leftPlayerName;
            document.getElementById('matchAbortedModal').classList.add('active');
            
            // Hide leave button
            document.getElementById('leaveBtn').classList.remove('active');
            
            // Clean up realtime subscription
            if (realtimeChannel) {
                realtimeChannel.unsubscribe();
            }
        }

        function startWaitingRoomPolling() {
            if (waitingRoomInterval) clearInterval(waitingRoomInterval);
            waitingRoomInterval = setInterval(() => {
                const currentScreen = document.querySelector('.screen.active').id;
                if (currentScreen === 'waitingScreen') {
                    updateWaitingRoom();
                } else {
                    clearInterval(waitingRoomInterval);
                    waitingRoomInterval = null;
                }
            }, 1000);
        }

        function botTurn() {
            const botHandValue = calculateHandValue(botHand);
            const playerHandValue = calculateHandValue(myHand);
            
            // Advanced show logic: call if ‚â§7 OR if ‚â§10 and player likely has higher
            if (botHandValue <= 7 || (botHandValue <= 10 && playerHandValue > botHandValue + 3)) {
                const playerScores = allPlayers.map(p => ({
                    name: p.player_name,
                    value: calculateHandValue(p.hand)
                }));
                
                const lowestScore = Math.min(...playerScores.map(p => p.value));
                const winner = playerScores.find(p => p.value === lowestScore);
                
                showGameOverModal(winner, playerScores);
                return;
            }
            
            // Bot throws cards
            const cardsToThrow = getBotThrow();
            gameState.discard_pile.push(...cardsToThrow);
            
            // Remove thrown cards from bot hand
            cardsToThrow.forEach(throwCard => {
                const index = botHand.findIndex(card => 
                    card.rank === throwCard.rank && card.suit === throwCard.suit
                );
                if (index !== -1) botHand.splice(index, 1);
            });
            
            allPlayers[1].hand = botHand;
            
            // Smart draw decision
            const shouldDrawFromDiscard = shouldBotDrawFromDiscard();
            
            if (shouldDrawFromDiscard) {
                const drawnCard = gameState.discard_pile.splice(-2, 1)[0];
                botHand.push(drawnCard);
            } else {
                const drawnCard = gameState.deck.pop();
                botHand.push(drawnCard);
            }
            
            allPlayers[1].hand = botHand;
            gameState.current_player = 0;
            
            renderGame();
        }
        
        function getBotThrow() {
            // Find all possible valid throws and rank them
            const allThrows = findAllValidThrows(botHand);
            
            // Score each throw: prioritize high-value cards, prefer sets/runs over singles
            const scoredThrows = allThrows.map(throwCards => {
                const totalValue = throwCards.reduce((sum, c) => sum + getCardValue(c), 0);
                const count = throwCards.length;
                const avgValue = totalValue / count;
                
                // Bonus for sets/runs (more efficient)
                const efficiencyBonus = count > 1 ? count * 5 : 0;
                
                return {
                    cards: throwCards,
                    score: totalValue + efficiencyBonus + avgValue
                };
            });
            
            // Return highest scoring throw
            scoredThrows.sort((a, b) => b.score - a.score);
            return scoredThrows[0].cards;
        }
        
        function findAllValidThrows(hand) {
            const throws = [];
            
            // Singles
            hand.forEach(card => throws.push([card]));
            
            // Pairs and sets (same rank)
            const byRank = {};
            hand.forEach(card => {
                if (!byRank[card.rank]) byRank[card.rank] = [];
                byRank[card.rank].push(card);
            });
            
            for (let rank in byRank) {
                if (byRank[rank].length >= 2) {
                    throws.push(byRank[rank].slice(0, 2));
                    if (byRank[rank].length >= 3) throws.push(byRank[rank].slice(0, 3));
                    if (byRank[rank].length === 4) throws.push(byRank[rank]);
                }
            }
            
            // Runs (consecutive same suit)
            const bySuit = {};
            hand.forEach(card => {
                if (card.rank !== 'JOKER') {
                    if (!bySuit[card.suit]) bySuit[card.suit] = [];
                    bySuit[card.suit].push(card);
                }
            });
            
            for (let suit in bySuit) {
                const cards = bySuit[suit].sort((a, b) => {
                    const aIdx = ranks.indexOf(a.rank);
                    const bIdx = ranks.indexOf(b.rank);
                    return aIdx - bIdx;
                });
                
                for (let i = 0; i < cards.length - 2; i++) {
                    const run = [cards[i]];
                    for (let j = i + 1; j < cards.length; j++) {
                        const lastIdx = ranks.indexOf(run[run.length - 1].rank);
                        const currIdx = ranks.indexOf(cards[j].rank);
                        if (currIdx === lastIdx + 1) {
                            run.push(cards[j]);
                        } else break;
                    }
                    if (run.length >= 3) throws.push([...run]);
                }
            }
            
            return throws;
        }
        
        function shouldBotDrawFromDiscard() {
            if (gameState.discard_pile.length < 2) return false;
            
            const topCard = gameState.discard_pile[gameState.discard_pile.length - 2];
            const topValue = getCardValue(topCard);
            
            // Never draw high cards
            if (topValue >= 8) return false;
            
            // Check if it completes a set
            const matchingRank = botHand.filter(c => c.rank === topCard.rank).length;
            if (matchingRank >= 1) return true;
            
            // Check if it completes a run
            const sameSuit = botHand.filter(c => c.suit === topCard.suit);
            if (sameSuit.length >= 2) {
                const topIdx = ranks.indexOf(topCard.rank);
                for (let card of sameSuit) {
                    const cardIdx = ranks.indexOf(card.rank);
                    if (Math.abs(cardIdx - topIdx) === 1) return true;
                }
            }
            
            // Draw low value cards (Ace, 2, 3)
            return topValue <= 3;
        }
        
        function getCardValue(card) {
            if (card.rank === 'JOKER') return 0;
            if (card.rank === 'A') return 1;
            if (['J', 'Q', 'K'].includes(card.rank)) return 10;
            return parseInt(card.rank);
        }
        
        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(screenId).classList.add('active');
            
            if (screenId !== 'waitingScreen' && waitingRoomInterval) {
                clearInterval(waitingRoomInterval);
                waitingRoomInterval = null;
            }
        }

        function showMessage(text, type) {
            const messageArea = document.getElementById('messageArea');
            const msgDiv = document.createElement('div');
            msgDiv.className = `message ${type}`;
            msgDiv.textContent = text;
            messageArea.innerHTML = '';
            messageArea.appendChild(msgDiv);
            setTimeout(() => msgDiv.remove(), 4000);
        }

        function showRules() {
            document.getElementById('rulesModal').classList.add('active');
        }

        function closeRules() {
            document.getElementById('rulesModal').classList.remove('active');
        }

        window.onclick = function(event) {
            const modal = document.getElementById('rulesModal');
            if (event.target === modal) {
                closeRules();
            }
        }
    </script>
</body>
</html>
