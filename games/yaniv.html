<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Yaniv - Card Game</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            color: white;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .screen {
            display: none;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            margin: 20px auto;
            max-width: 800px;
        }

        .screen.active {
            display: block;
        }

        h1 {
            font-size: 3em;
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .subtitle {
            text-align: center;
            font-size: 1.2em;
            opacity: 0.9;
            margin-bottom: 30px;
        }

        .config-section {
            background: rgba(255, 255, 255, 0.05);
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            font-size: 1.1em;
        }

        input[type="text"], select {
            width: 100%;
            padding: 12px;
            font-size: 1.1em;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            margin-bottom: 15px;
        }

        input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .btn {
            padding: 15px 40px;
            font-size: 1.2em;
            background: #4CAF50;
            border: none;
            border-radius: 10px;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            width: 100%;
            margin-top: 10px;
        }

        .btn:hover {
            background: #45a049;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .btn:disabled {
            background: #95a5a6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: #3498db;
        }

        .btn-secondary:hover {
            background: #2980b9;
        }

        .waiting-area {
            text-align: center;
            padding: 30px;
        }

        .room-code-display {
            font-size: 2.5em;
            background: rgba(255, 215, 0, 0.2);
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            letter-spacing: 5px;
            font-weight: bold;
        }

        .players-waiting {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .player-badge {
            background: rgba(255, 255, 255, 0.15);
            padding: 15px;
            border-radius: 10px;
            font-size: 1.2em;
        }

        .game-board {
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .opponents-area {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 15px;
        }

        .opponent-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 10px;
            border: 2px solid transparent;
        }

        .opponent-card.active {
            border-color: #4CAF50;
            box-shadow: 0 0 15px rgba(76, 175, 80, 0.5);
        }

        .center-area {
            text-align: center;
        }

        .discard-section {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .discard-pile, .my-throw-pile {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 15px;
            min-height: 150px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        .discard-pile {
            cursor: pointer;
            border: 2px solid rgba(76, 175, 80, 0.3);
        }

        .discard-pile:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(76, 175, 80, 0.6);
        }

        .my-throw-pile {
            border: 2px solid rgba(231, 76, 60, 0.3);
        }

        .pile-label {
            font-size: 0.9em;
            opacity: 0.8;
            margin-bottom: 5px;
        }

        .pile-cards {
            display: flex;
            flex-wrap: wrap;
            gap: 3px;
            justify-content: center;
        }

        .deck-pile {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 15px;
            min-height: 150px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .deck-pile:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: scale(1.05);
        }

        .info-area {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 15px;
        }

        .stat-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .my-hand {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 15px;
            margin-top: 20px;
        }

        .cards-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
            min-height: 140px;
        }

        .card {
            width: 70px;
            height: 100px;
            background: white;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }

        .card:hover {
            transform: translateY(-10px);
        }

        .card.selected {
            transform: translateY(-20px);
            box-shadow: 0 8px 16px rgba(76, 175, 80, 0.6);
            border: 3px solid #4CAF50;
        }

        .card.red {
            color: #e74c3c;
        }

        .card.black {
            color: #2c3e50;
        }

        .card.joker {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .card-back {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .card.small {
            width: 50px;
            height: 70px;
            font-size: 1.1em;
        }

        .card-value {
            font-size: 1.3em;
        }

        .card-suit {
            font-size: 1.1em;
            margin-top: -5px;
        }

        .card.small .card-value {
            font-size: 1em;
        }

        .card.small .card-suit {
            font-size: 0.8em;
        }

        .actions-area {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        .action-btn {
            padding: 12px 30px;
            font-size: 1.1em;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }

        .action-btn.throw {
            background: #3498db;
            color: white;
        }

        .action-btn.show {
            background: #f39c12;
            color: white;
        }

        .action-btn:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .action-btn:disabled {
            background: #95a5a6;
            cursor: not-allowed;
            opacity: 0.5;
        }

        .rules-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid white;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            z-index: 100;
        }

        .rules-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .leave-btn {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            background: rgba(231, 76, 60, 0.3);
            border: 2px solid #e74c3c;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            z-index: 100;
            display: none;
        }

        .leave-btn:hover {
            background: rgba(231, 76, 60, 0.5);
        }

        .leave-btn.active {
            display: block;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 40px;
            border-radius: 20px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }

        .game-over-modal {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            padding: 50px;
            border-radius: 30px;
            max-width: 700px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            animation: slideIn 0.5s ease-out;
        }

        @keyframes slideIn {
            from {
                transform: translateY(-100px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .winner-banner {
            font-size: 3em;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
        }

        .winner-name {
            font-size: 2.5em;
            color: #f39c12;
            margin-bottom: 30px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .scores-table {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin: 30px 0;
        }

        .score-row {
            display: flex;
            justify-content: space-between;
            padding: 15px 20px;
            margin: 10px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            font-size: 1.3em;
            transition: all 0.3s;
        }

        .score-row:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: scale(1.02);
        }

        .score-row.winner-row {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
            box-shadow: 0 0 20px rgba(243, 156, 18, 0.5);
            font-weight: bold;
        }

        .play-again-btn {
            padding: 20px 50px;
            font-size: 1.5em;
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            border: none;
            border-radius: 15px;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            margin-top: 20px;
            box-shadow: 0 5px 20px rgba(76, 175, 80, 0.4);
        }

        .play-again-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(76, 175, 80, 0.6);
        }

        .close-btn {
            position: absolute;
            top: 10px;
            right: 20px;
            font-size: 2em;
            cursor: pointer;
            color: white;
        }

        .message {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            text-align: center;
            font-weight: bold;
        }

        .error {
            background: rgba(231, 76, 60, 0.3);
            border: 2px solid #e74c3c;
        }

        .success {
            background: rgba(76, 175, 80, 0.3);
            border: 2px solid #4CAF50;
        }

        .turn-indicator {
            background: rgba(76, 175, 80, 0.3);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            font-size: 1.3em;
            margin-bottom: 20px;
            font-weight: bold;
        }

        .confirm-modal {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 40px;
            border-radius: 20px;
            max-width: 500px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        .confirm-modal h2 {
            color: #fff;
            margin-bottom: 20px;
            font-size: 2em;
        }

        .confirm-modal p {
            color: rgba(255, 255, 255, 0.9);
        }

        .confirm-buttons {
            display: flex;
            gap: 20px;
            margin-top: 30px;
            justify-content: center;
        }

        .confirm-btn {
            padding: 15px 40px;
            font-size: 1.2em;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        .confirm-btn.yes {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
        }

        .confirm-btn.no {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
        }

        .confirm-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }

        .abort-modal {
            background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
            padding: 50px;
            border-radius: 30px;
            max-width: 600px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            animation: slideIn 0.5s ease-out;
        }

        .abort-banner {
            font-size: 3em;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(231, 76, 60, 0.8);
        }

        .abort-message {
            font-size: 1.8em;
            color: #e74c3c;
            margin-bottom: 20px;
            font-weight: bold;
        }

        .abort-details {
            font-size: 1.2em;
            opacity: 0.9;
            margin-bottom: 30px;
            line-height: 1.6;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }

            .screen {
                padding: 20px;
                margin: 10px;
            }

            h1 {
                font-size: 2em;
            }

            .game-board {
                grid-template-columns: 1fr;
                gap: 10px;
            }

            .discard-section {
                flex-direction: column;
            }

            .card {
                width: 55px;
                height: 80px;
                font-size: 1.2em;
            }

            .card.small {
                width: 40px;
                height: 60px;
                font-size: 0.9em;
            }

            .my-hand {
                padding: 15px;
            }

            .actions-area {
                flex-direction: column;
            }

            .action-btn {
                width: 100%;
            }

            .room-code-display {
                font-size: 1.8em;
                padding: 15px;
            }

            .config-section {
                padding: 15px;
            }

            .modal-content, .game-over-modal,             .confirm-modal, .abort-modal {
                margin: 20px;
                max-width: 90%;
                padding: 30px 20px;
            }

            .winner-banner, .abort-banner {
                font-size: 2em;
            }

            .winner-name, .abort-message {
                font-size: 1.5em;
            }
        }
    </style>
</head>
<body>
    <button class="rules-btn" onclick="showRules()">📖 Rules</button>
    <button class="leave-btn" id="leaveBtn" onclick="showLeaveConfirmation()">🚪 Leave Game</button>
    
    <div class="container">
        <div id="messageArea"></div>

        <!-- Setup Screen -->
        <div class="screen active" id="setupScreen">
            <h1>🃏 Yaniv</h1>
            <p class="subtitle">Call "Show" to win with ≤10 points!</p>
            
            <div class="config-section">
                <h2 style="margin-bottom: 20px;">🎮 Start Game</h2>
                <label>Your Name</label>
                <input type="text" id="playerName" placeholder="Enter your name">
                
                <label>Number of Players</label>
                <select id="numPlayers">
                    <option value="2">2 Players</option>
                    <option value="3">3 Players</option>
                    <option value="4">4 Players</option>
                </select>
                
                <button class="btn" onclick="createGame()">🎲 Create New Game</button>
            </div>
            
            <div class="config-section">
                <h2 style="margin-bottom: 20px;">🔗 Join Game</h2>
                <label>Your Name</label>
                <input type="text" id="joinPlayerName" placeholder="Enter your name">
                
                <label>Room Code</label>
                <input type="text" id="roomCode" placeholder="Enter room code">
                
                <button class="btn btn-secondary" onclick="joinGame()" id="joinBtn">🚪 Join Game</button>
            </div>
        </div>

        <!-- Waiting Room -->
        <div class="screen" id="waitingScreen">
            <div class="waiting-area">
                <h1>⏳ Waiting for Players</h1>
                <div class="room-code-display" id="displayRoomCode"></div>
                <p style="font-size: 1.2em; margin-bottom: 20px;">Share this code with your friends!</p>
                
                <div class="players-waiting" id="playersWaiting"></div>
                
                <button class="btn" id="startGameBtn" onclick="startGame()" style="max-width: 400px; margin: 20px auto;">
                    🚀 Start Game
                </button>
            </div>
        </div>

        <!-- Game Screen -->
        <div class="screen" id="gameScreen" style="max-width: 1400px;">
            <div id="turnIndicator" class="turn-indicator"></div>
            
            <div class="game-board">
                <div class="opponents-area" id="opponentsArea"></div>
                
                <div class="center-area">
                    <div class="discard-section">
                        <div class="discard-pile" onclick="drawFromDiscard()">
                            <div class="pile-label">⬆️ Opponent's Cards (Click to pick)</div>
                            <div class="pile-cards" id="opponentDiscardPile"></div>
                        </div>
                        <div class="my-throw-pile">
                            <div class="pile-label">🎯 Your Thrown Cards</div>
                            <div class="pile-cards" id="myThrowPile"></div>
                        </div>
                    </div>
                    
                    <h3>Draw Deck</h3>
                    <div class="deck-pile" onclick="drawCard()">
                        <div class="card card-back">
                            <div>🂠</div>
                            <div style="font-size: 0.6em; margin-top: 5px;">Draw</div>
                        </div>
                    </div>
                </div>
                
                <div class="info-area">
                    <h3 style="margin-bottom: 15px;">Game Info</h3>
                    <div class="stat-item">
                        👤 <span id="currentPlayerName">Player</span>
                    </div>
                    <div class="stat-item">
                        🎯 Hand Value: <span id="handValue">0</span>
                    </div>
                    <div class="stat-item">
                        🃏 Cards: <span id="cardsCount">0</span>
                    </div>
                    <div class="stat-item">
                        📊 Deck: <span id="deckCount">0</span>
                    </div>
                </div>
            </div>
            
            <div class="my-hand">
                <h2 style="text-align: center; margin-bottom: 15px;">Your Hand</h2>
                <div class="cards-container" id="myHand"></div>
                
                <div class="actions-area">
                    <button class="action-btn throw" onclick="throwCards()" id="throwBtn">
                        🎯 Throw Selected Cards
                    </button>
                    <button class="action-btn show" onclick="callShow()" id="showBtn">
                        🏆 Call SHOW!
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Confirm Leave Modal -->
    <div class="modal" id="confirmLeaveModal">
        <div class="confirm-modal">
            <h2 style="margin-bottom: 20px;">⚠️ Leave Game?</h2>
            <p style="font-size: 1.2em;">Are you sure you want to leave the game?</p>
            <p style="font-size: 1em; opacity: 0.8; margin-top: 10px;">You won't be able to rejoin this match.</p>
            <div class="confirm-buttons">
                <button class="confirm-btn yes" onclick="confirmLeaveGame()">Yes, Leave</button>
                <button class="confirm-btn no" onclick="cancelLeaveGame()">Stay in Game</button>
            </div>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div class="modal" id="gameOverModal">
        <div class="game-over-modal">
            <div class="winner-banner">🏆 GAME OVER 🏆</div>
            <div class="winner-name" id="winnerName"></div>
            <div class="scores-table" id="finalScores"></div>
            <button class="play-again-btn" onclick="location.reload()">🎮 Play Again</button>
        </div>
    </div>

    <!-- Match Aborted Modal -->
    <div class="modal" id="matchAbortedModal">
        <div class="abort-modal">
            <div class="abort-banner">⚠️ MATCH ABORTED </div>
            <div class="abort-message">A player has left the game</div>
            <div class="abort-details">
                <p><strong id="leftPlayerName"></strong> has disconnected from the match.</p>
                <p>The game cannot continue and has been terminated.</p>
            </div>
            <button class="play-again-btn" onclick="location.reload()">🎮 New Game</button>
        </div>
    </div>

    <!-- Rules Modal -->
    <div class="modal" id="rulesModal">
        <div class="modal-content">
            <span class="close-btn" onclick="closeRules()">&times;</span>
            <div>
                <h2>How to Play Yaniv</h2>
                <h3 style="margin-top: 20px;">Objective:</h3>
                <p>Be the first to call "SHOW" with a hand value of 10 or less!</p>
                
                <h3 style="margin-top: 20px;">Card Values:</h3>
                <ul style="margin-left: 20px; line-height: 1.8;">
                    <li>Ace = 1 point</li>
                    <li>2-10 = Face value</li>
                    <li>J, Q, K = 10 points each</li>
                    <li>Joker = 0 points</li>
                </ul>
                
                <h3 style="margin-top: 20px;">Gameplay:</h3>
                <ul style="margin-left: 20px; line-height: 1.8;">
                    <li>Start with 7 cards</li>
                    <li>On your turn: Throw valid cards, then draw one</li>
                    <li><strong>Valid Throws:</strong></li>
                    <li>- Single card</li>
                    <li>- Pairs/Sets: 2+ cards of same rank (7-7 or 7-7-7)</li>
                    <li>- Runs: 3+ consecutive cards of same suit (3♥-4♥-5♥)</li>
                    <li>Draw from deck OR pick opponent's last card from discard pile</li>
                    <li>Call "SHOW" when you have ≤10 points</li>
                    <li>Everyone reveals - lowest hand wins!</li>
                </ul>
                
                <h3 style="margin-top: 20px;">Tips:</h3>
                <ul style="margin-left: 20px; line-height: 1.8;">
                    <li>Keep Aces and low cards</li>
                    <li>Get rid of face cards quickly</li>
                    <li>Watch what others discard</li>
                    <li>You can call SHOW even with more than 3 cards if total ≤10</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // Hardcoded Supabase credentials
        const SUPABASE_URL = 'https://tkdxculbojbfpckwtfpx.supabase.co';
        const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRrZHhjdWxib2piZnBja3d0ZnB4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjEzOTc0MDUsImV4cCI6MjA3Njk3MzQwNX0.TFvv15rgzjNRIj0oQhzsyjXCuYDzA1Uzo8hFLUaf7Vg';
        
        let supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
        let gameId;
        let playerId;
        let playerIndex;
        let playerName;
        let myHand = [];
        let selectedCards = [];
        let gameState = {};
        let allPlayers = [];
        let realtimeChannel;
        let hasThrown = false;
        let isCreator = false;
        let myThrownCards = [];
        let opponentDiscardCards = [];
        let isJoining = false;

        const suits = ['♠', '♥', '♦', '♣'];
        const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];

        // Prevent back navigation and show confirmation
        let isInGame = false;

        window.addEventListener('load', () => {
            history.pushState(null, '', location.href);
            restoreGameState();
        });

        window.addEventListener('popstate', (e) => {
            if (isInGame) {
                e.preventDefault();
                history.pushState(null, '', location.href);
                showLeaveConfirmation();
            }
        });

        window.addEventListener('beforeunload', (e) => {
            if (isInGame) {
                e.preventDefault();
                e.returnValue = '';
                return '';
            }
        });

        function showLeaveConfirmation() {
            document.getElementById('confirmLeaveModal').classList.add('active');
        }

        function confirmLeaveGame() {
            isInGame = false;
            localStorage.removeItem('yanivGameState');
            document.getElementById('confirmLeaveModal').classList.remove('active');
            
            // Notify other players by deleting this player and marking game as aborted
            notifyGameAborted();
            
            // Clean up realtime subscription
            if (realtimeChannel) {
                realtimeChannel.unsubscribe();
            }
            
            // Reset all game variables
            gameId = null;
            playerId = null;
            playerIndex = null;
            playerName = null;
            myHand = [];
            selectedCards = [];
            gameState = {};
            allPlayers = [];
            hasThrown = false;
            isCreator = false;
            myThrownCards = [];
            opponentDiscardCards = [];
            
            // Hide leave button
            document.getElementById('leaveBtn').classList.remove('active');
            
            // Show success message and go back to setup
            showScreen('setupScreen');
            showMessage('You have left the game', 'success');
        }

        async function notifyGameAborted() {
            try {
                // Mark the game as aborted and store who left
                await supabase
                    .from('yaniv_games')
                    .update({ 
                        status: 'aborted',
                        winner_name: playerName // Store who left in winner_name field
                    })
                    .eq('id', gameId);
                
                // Delete the player who left
                await supabase
                    .from('yaniv_players')
                    .delete()
                    .eq('id', playerId);
            } catch (error) {
                console.error('Error notifying game abort:', error);
            }
        }

        function cancelLeaveGame() {
            document.getElementById('confirmLeaveModal').classList.remove('active');
        }

        // Save game state to localStorage
        function saveGameState() {
            const state = {
                gameId,
                playerId,
                playerIndex,
                playerName,
                isCreator,
                timestamp: Date.now()
            };
            localStorage.setItem('yanivGameState', JSON.stringify(state));
        }

        // Restore game state from localStorage
        async function restoreGameState() {
            const saved = localStorage.getItem('yanivGameState');
            if (!saved) return;

            try {
                const state = JSON.parse(saved);
                
                // Check if state is recent (within 1 hour)
                if (Date.now() - state.timestamp > 3600000) {
                    localStorage.removeItem('yanivGameState');
                    return;
                }

                gameId = state.gameId;
                playerId = state.playerId;
                playerIndex = state.playerIndex;
                playerName = state.playerName;
                isCreator = state.isCreator;

                // Check if game still exists
                const { data: game } = await supabase
                    .from('yaniv_games')
                    .select('*')
                    .eq('id', gameId)
                    .single();

                if (!game) {
                    localStorage.removeItem('yanivGameState');
                    return;
                }

                isInGame = true;
                setupRealtimeSubscription();

                if (game.status === 'waiting') {
                    document.getElementById('leaveBtn').classList.add('active');
                    showScreen('waitingScreen');
                    document.getElementById('displayRoomCode').textContent = game.room_code;
                    updateWaitingRoom();
                } else if (game.status === 'playing') {
                    document.getElementById('leaveBtn').classList.add('active');
                    showScreen('gameScreen');
                    loadGameState();
                }
            } catch (error) {
                console.error('Error restoring game state:', error);
                localStorage.removeItem('yanivGameState');
            }
        }

        function generateRoomCode() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }

        function createDeck() {
            const deck = [];
            for (let suit of suits) {
                for (let rank of ranks) {
                    deck.push({ rank, suit });
                }
            }
            deck.push({ rank: 'JOKER', suit: '🃏' });
            deck.push({ rank: 'JOKER', suit: '🃏' });
            
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            return deck;
        }

        async function createGame() {
            playerName = document.getElementById('playerName').value.trim();
            
            if (!playerName) {
                showMessage('Please enter your name', 'error');
                return;
            }
            
            const roomCode = generateRoomCode();
            const deck = createDeck();
            
            try {
                const { data: game, error: gameError } = await supabase
                    .from('yaniv_games')
                    .insert({
                        room_code: roomCode,
                        status: 'waiting',
                        deck: deck,
                        discard_pile: [],
                        current_player: 0
                    })
                    .select()
                    .single();
                
                if (gameError) throw gameError;
                
                gameId = game.id;
                playerIndex = 0;
                isCreator = true;
                
                const { data: player, error: playerError } = await supabase
                    .from('yaniv_players')
                    .insert({
                        game_id: gameId,
                        player_name: playerName,
                        player_index: 0,
                        hand: [],
                        score: 0
                    })
                    .select()
                    .single();
                
                if (playerError) throw playerError;
                
                playerId = player.id;
                isInGame = true;

                document.getElementById('displayRoomCode').textContent = roomCode;
                document.getElementById('leaveBtn').classList.add('active');
                showScreen('waitingScreen');
                setupRealtimeSubscription();
                updateWaitingRoom();
                saveGameState();
            } catch (error) {
                showMessage('Failed to create game: ' + error.message, 'error');
            }
        }

        async function joinGame() {
            if (isJoining) return;
            isJoining = true;
            
            const joinBtn = document.getElementById('joinBtn');
            joinBtn.disabled = true;
            
            playerName = document.getElementById('joinPlayerName').value.trim();
            const roomCode = document.getElementById('roomCode').value.trim().toUpperCase();
            
            if (!playerName || !roomCode) {
                showMessage('Please enter your name and room code', 'error');
                isJoining = false;
                joinBtn.disabled = false;
                return;
            }
            
            try {
                const { data: games, error: gameError } = await supabase
                    .from('yaniv_games')
                    .select('*')
                    .eq('room_code', roomCode)
                    .eq('status', 'waiting')
                    .single();
                
                if (gameError) throw new Error('Game not found or already started');
                
                const { data: existingPlayers } = await supabase
                    .from('yaniv_players')
                    .select('*')
                    .eq('game_id', games.id);
                
                if (existingPlayers.length >= 4) {
                    throw new Error('Game is full');
                }
                
                gameId = games.id;
                playerIndex = existingPlayers.length;
                
                const { data: player, error: playerError } = await supabase
                    .from('yaniv_players')
                    .insert({
                        game_id: gameId,
                        player_name: playerName,
                        player_index: playerIndex,
                        hand: [],
                        score: 0
                    })
                    .select()
                    .single();
                
                if (playerError) throw playerError;
                
                playerId = player.id;
                isInGame = true;

                document.getElementById('displayRoomCode').textContent = roomCode;
                document.getElementById('leaveBtn').classList.add('active');
                showScreen('waitingScreen');
                setupRealtimeSubscription();
                updateWaitingRoom();
                saveGameState();
            } catch (error) {
                showMessage('Failed to join game: ' + error.message, 'error');
            } finally {
                isJoining = false;
                joinBtn.disabled = false;
            }
        }

        async function updateWaitingRoom() {
            try {
                const { data: players } = await supabase
                    .from('yaniv_players')
                    .select('*')
                    .eq('game_id', gameId)
                    .order('player_index');
                
                const container = document.getElementById('playersWaiting');
                container.innerHTML = players.map(p => 
                    `<div class="player-badge">👤 ${p.player_name}</div>`
                ).join('');
                
                const startBtn = document.getElementById('startGameBtn');
                startBtn.disabled = players.length < 2 || players[0].id !== playerId;
            } catch (error) {
                console.error('Error updating waiting room:', error);
            }
        }

        async function startGame() {
            try {
                const { data: players } = await supabase
                    .from('yaniv_players')
                    .select('*')
                    .eq('game_id', gameId)
                    .order('player_index');
                
                if (players.length < 2) {
                    showMessage('Need at least 2 players to start', 'error');
                    return;
                }
                
                const { data: game } = await supabase
                    .from('yaniv_games')
                    .select('deck')
                    .eq('id', gameId)
                    .single();
                
                let deck = [...game.deck];
                
                for (let player of players) {
                    const hand = [];
                    for (let i = 0; i < 7; i++) {
                        hand.push(deck.pop());
                    }
                    
                    await supabase
                        .from('yaniv_players')
                        .update({ hand: hand })
                        .eq('id', player.id);
                }
                
                const discardPile = [deck.pop()];
                
                await supabase
                    .from('yaniv_games')
                    .update({
                        status: 'playing',
                        deck: deck,
                        discard_pile: discardPile,
                        current_player: 0
                    })
                    .eq('id', gameId);
                
            } catch (error) {
                showMessage('Failed to start game: ' + error.message, 'error');
            }
        }

        function setupRealtimeSubscription() {
            realtimeChannel = supabase
                .channel('game-changes')
                .on('postgres_changes',
                    { event: '*', schema: 'public', table: 'yaniv_games', filter: `id=eq.${gameId}` },
                    handleGameUpdate
                )
                .on('postgres_changes',
                    { event: '*', schema: 'public', table: 'yaniv_players', filter: `game_id=eq.${gameId}` },
                    handlePlayerUpdate
                )
                .subscribe();
        }

        function handleGameUpdate(payload) {
            if (payload.new.status === 'playing') {
                loadGameState();
            } else if (payload.new.status === 'finished') {
                showGameResult();
            } else if (payload.new.status === 'aborted') {
                showMatchAborted(payload.new.winner_name);
            } else {
                updateWaitingRoom();
            }
        }

        function handlePlayerUpdate() {
            const currentScreen = document.querySelector('.screen.active').id;
            if (currentScreen === 'waitingScreen') {
                updateWaitingRoom();
            } else if (currentScreen === 'gameScreen') {
                loadGameState();
            }
        }

        async function loadGameState() {
            try {
                const { data: game } = await supabase
                    .from('yaniv_games')
                    .select('*')
                    .eq('id', gameId)
                    .single();
                
                const { data: players } = await supabase
                    .from('yaniv_players')
                    .select('*')
                    .eq('game_id', gameId)
                    .order('player_index');
                
                gameState = game;
                allPlayers = players;
                
                const myPlayer = players.find(p => p.id === playerId);
                myHand = myPlayer.hand || [];
                
                showScreen('gameScreen');
                renderGame();
            } catch (error) {
                console.error('Error loading game state:', error);
            }
        }

        function renderGame() {
            const currentPlayer = allPlayers[gameState.current_player];
            const isMyTurn = currentPlayer.id === playerId;
            
            if (!isMyTurn) {
                selectedCards = [];
            }
            
            // Render my hand
            document.getElementById('myHand').innerHTML = myHand.map((card, idx) => 
                renderCard(card, idx, false)
            ).join('');
            
            // Split discard pile into opponent's cards and my thrown cards
            const totalDiscard = gameState.discard_pile || [];
            
            if (myThrownCards.length > 0 && isMyTurn && !hasThrown) {
                // Keep showing my previously thrown cards until I throw again
                document.getElementById('myThrowPile').innerHTML = myThrownCards.map(card => 
                    renderCard(card, undefined, true)
                ).join('');
            } else if (hasThrown && selectedCards.length === 0) {
                // Show cards I just threw
                const justThrown = totalDiscard.slice(-myThrownCards.length);
                document.getElementById('myThrowPile').innerHTML = justThrown.map(card => 
                    renderCard(card, undefined, true)
                ).join('');
            } else {
                document.getElementById('myThrowPile').innerHTML = '<p style="opacity: 0.5; font-size: 0.9em;">No cards thrown yet</p>';
            }
            
            // Show opponent's discard (all cards except my thrown ones)
            const myThrowCount = hasThrown ? myThrownCards.length : 0;
            const opponentCards = totalDiscard.slice(0, totalDiscard.length - myThrowCount);
            
            if (opponentCards.length > 0) {
                // Show last 5 cards from opponents
                const displayCards = opponentCards.slice(-5);
                document.getElementById('opponentDiscardPile').innerHTML = displayCards.map(card => 
                    renderCard(card, undefined, true)
                ).join('');
            } else {
                document.getElementById('opponentDiscardPile').innerHTML = '<p style="opacity: 0.5; font-size: 0.9em;">Empty</p>';
            }
            
            document.getElementById('turnIndicator').textContent = isMyTurn 
                ? '🎯 YOUR TURN!' 
                : `⏳ Waiting for ${currentPlayer.player_name}...`;
            
            document.getElementById('currentPlayerName').textContent = playerName;
            document.getElementById('handValue').textContent = calculateHandValue(myHand);
            document.getElementById('cardsCount').textContent = myHand.length;
            document.getElementById('deckCount').textContent = gameState.deck.length;
            
            const opponentsHtml = allPlayers
                .filter(p => p.id !== playerId)
                .map(p => `
                    <div class="opponent-card ${p.player_index === gameState.current_player ? 'active' : ''}">
                        <div style="font-weight: bold; margin-bottom: 5px;">${p.player_name}</div>
                        <div>🃏 ${p.hand.length} cards</div>
                    </div>
                `).join('');
            
            document.getElementById('opponentsArea').innerHTML = opponentsHtml;
            
            const handValue = calculateHandValue(myHand);
            document.getElementById('showBtn').disabled = !isMyTurn || handValue > 10;
            document.getElementById('throwBtn').disabled = !isMyTurn || selectedCards.length === 0 || hasThrown;
        }

        function renderCard(card, index, isSmall = false) {
            const isRed = card.suit === '♥' || card.suit === '♦';
            const isJoker = card.rank === 'JOKER';
            const isSelected = index !== undefined && selectedCards.includes(index);
            
            return `
                <div class="card ${isSmall ? 'small' : ''} ${isJoker ? 'joker' : (isRed ? 'red' : 'black')} ${isSelected ? 'selected' : ''}" 
                     ${index !== undefined ? `onclick="toggleCardSelection(${index})"` : ''}>
                    <div class="card-value">${card.rank}</div>
                    <div class="card-suit">${card.suit}</div>
                </div>
            `;
        }

        function toggleCardSelection(index) {
            const currentPlayer = allPlayers[gameState.current_player];
            if (currentPlayer.id !== playerId) {
                showMessage('Not your turn!', 'error');
                return;
            }
            
            const cardIndex = selectedCards.indexOf(index);
            if (cardIndex > -1) {
                selectedCards.splice(cardIndex, 1);
            } else {
                selectedCards.push(index);
            }
            renderGame();
        }

        function calculateHandValue(hand) {
            return hand.reduce((sum, card) => {
                if (card.rank === 'JOKER') return sum;
                if (card.rank === 'A') return sum + 1;
                if (['J', 'Q', 'K'].includes(card.rank)) return sum + 10;
                return sum + parseInt(card.rank);
            }, 0);
        }

        function isValidThrow(cards) {
            if (cards.length === 1) return true;
            
            if (cards.length === 2) {
                return cards[0].rank === cards[1].rank;
            }
            
            const ranks = cards.map(c => c.rank);
            const suits = cards.map(c => c.suit);
            
            const allSameRank = ranks.every(r => r === ranks[0]);
            if (allSameRank) return true;
            
            if (suits.every(s => s === suits[0])) {
                const rankValues = cards.map(c => {
                    const idx = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'].indexOf(c.rank);
                    return idx;
                }).sort((a, b) => a - b);
                
                for (let i = 1; i < rankValues.length; i++) {
                    if (rankValues[i] !== rankValues[i-1] + 1) return false;
                }
                return true;
            }
            
            return false;
        }

        async function throwCards() {
            const currentPlayer = allPlayers[gameState.current_player];
            if (currentPlayer.id !== playerId) {
                showMessage('Not your turn!', 'error');
                return;
            }
            
            if (hasThrown) {
                showMessage('You already threw cards. Now draw a card!', 'error');
                return;
            }
            
            if (selectedCards.length === 0) {
                showMessage('Select cards to throw', 'error');
                return;
            }
            
            const cardsToThrow = selectedCards.map(i => myHand[i]);
            
            if (!isValidThrow(cardsToThrow)) {
                showMessage('Invalid throw! Must be single, pair/set, or run of 3+', 'error');
                return;
            }
            
            try {
                const { data: latestGame } = await supabase
                    .from('yaniv_games')
                    .select('discard_pile')
                    .eq('id', gameId)
                    .single();
                
                const newHand = myHand.filter((_, i) => !selectedCards.includes(i));
                const newDiscard = [...latestGame.discard_pile, ...cardsToThrow];
                
                await supabase
                    .from('yaniv_players')
                    .update({ hand: newHand })
                    .eq('id', playerId);
                
                await supabase
                    .from('yaniv_games')
                    .update({ discard_pile: newDiscard })
                    .eq('id', gameId);
                
                myHand = newHand;
                gameState.discard_pile = newDiscard;
                hasThrown = true;
                myThrownCards = cardsToThrow;
                selectedCards = [];
                
                showMessage('Cards thrown! Now draw a card.', 'success');
                renderGame();
            } catch (error) {
                showMessage('Failed to throw cards: ' + error.message, 'error');
            }
        }

        async function drawCard() {
            const currentPlayer = allPlayers[gameState.current_player];
            if (currentPlayer.id !== playerId) {
                showMessage('Not your turn!', 'error');
                return;
            }
            
            if (!hasThrown) {
                showMessage('Throw cards first!', 'error');
                return;
            }
            
            try {
                const newDeck = [...gameState.deck];
                if (newDeck.length === 0) {
                    showMessage('Deck is empty!', 'error');
                    return;
                }
                
                const drawnCard = newDeck.pop();
                const newHand = [...myHand, drawnCard];
                
                const nextPlayer = (gameState.current_player + 1) % allPlayers.length;
                
                await supabase
                    .from('yaniv_players')
                    .update({ hand: newHand })
                    .eq('id', playerId);
                
                await supabase
                    .from('yaniv_games')
                    .update({ 
                        deck: newDeck,
                        current_player: nextPlayer
                    })
                    .eq('id', gameId);
                
                myHand = newHand;
                hasThrown = false;
                myThrownCards = [];
                selectedCards = [];
                
            } catch (error) {
                showMessage('Failed to draw card: ' + error.message, 'error');
            }
        }

        async function drawFromDiscard() {
            const currentPlayer = allPlayers[gameState.current_player];
            if (currentPlayer.id !== playerId) {
                showMessage('Not your turn!', 'error');
                return;
            }
            
            if (!hasThrown) {
                showMessage('Throw cards first!', 'error');
                return;
            }
            
            const { data: latestGame } = await supabase
                .from('yaniv_games')
                .select('discard_pile')
                .eq('id', gameId)
                .single();
            
            if (!latestGame || latestGame.discard_pile.length === 0) {
                showMessage('Discard pile is empty!', 'error');
                return;
            }
            
            try {
                const currentDiscard = [...latestGame.discard_pile];
                
                // Remove my thrown cards to get opponent's cards
                const myThrowCount = myThrownCards.length;
                let availableCards = currentDiscard.slice(0, currentDiscard.length - myThrowCount);
                
                if (availableCards.length === 0) {
                    showMessage('No opponent cards to pick!', 'error');
                    return;
                }
                
                // Pick the last card from opponent's pile
                const drawnCard = availableCards[availableCards.length - 1];
                
                // Remove that card from the full discard pile
                const newDiscard = [...currentDiscard];
                const cardIdx = newDiscard.lastIndexOf(drawnCard);
                if (cardIdx !== -1) {
                    newDiscard.splice(cardIdx, 1);
                }
                
                const newHand = [...myHand, drawnCard];
                const nextPlayer = (gameState.current_player + 1) % allPlayers.length;
                
                await supabase
                    .from('yaniv_players')
                    .update({ hand: newHand })
                    .eq('id', playerId);
                
                await supabase
                    .from('yaniv_games')
                    .update({ 
                        discard_pile: newDiscard,
                        current_player: nextPlayer
                    })
                    .eq('id', gameId);
                
                myHand = newHand;
                hasThrown = false;
                myThrownCards = [];
                selectedCards = [];
                
            } catch (error) {
                showMessage('Failed to draw from discard: ' + error.message, 'error');
            }
        }

        async function showGameResult() {
            try {
                const { data: gameData } = await supabase
                    .from('yaniv_games')
                    .select('*')
                    .eq('id', gameId)
                    .single();
                
                if (!gameData) return;

                const { data: currentPlayers } = await supabase
                    .from('yaniv_players')
                    .select('*')
                    .eq('game_id', gameId)
                    .order('player_index');
                
                if (!currentPlayers) return;

                const playerScores = currentPlayers.map(p => ({
                    name: p.player_name,
                    value: calculateHandValue(p.hand)
                }));

                const winner = playerScores.find(p => p.name === gameData.winner_name);
                if (!winner) return;

                showGameOverModal(winner, playerScores);
            } catch (error) {
                console.error("Error in showGameResult:", error);
            }
        }

        async function callShow() {
            const currentPlayer = allPlayers[gameState.current_player];
            if (currentPlayer.id !== playerId) {
                showMessage('Not your turn!', 'error');
                return;
            }
            
            const handValue = calculateHandValue(myHand);
            if (handValue > 10) {
                showMessage('Your hand value must be 10 or less to call SHOW!', 'error');
                return;
            }
            
            if (!confirm(`Call SHOW with ${myHand.length} cards totaling ${handValue} points?`)) {
                return;
            }
            
            try {
                const { data: currentPlayers } = await supabase
                    .from('yaniv_players')
                    .select('*')
                    .eq('game_id', gameId)
                    .order('player_index');
                
                const playerScores = currentPlayers.map(p => ({
                    name: p.player_name,
                    value: calculateHandValue(p.hand)
                }));
                
                const lowestScore = Math.min(...playerScores.map(p => p.value));
                const winner = playerScores.find(p => p.value === lowestScore);
                
                await supabase
                    .from('yaniv_games')
                    .update({
                        status: 'finished',
                        winner_name: winner.name
                    })
                    .eq('id', gameId);
                
                isInGame = false;
                localStorage.removeItem('yanivGameState');
                
            } catch (error) {
                showMessage('Failed to call SHOW: ' + error.message, 'error');
            }
        }

        function showGameOverModal(winner, playerScores) {
            document.getElementById('winnerName').textContent = `${winner.name} Wins!`;
            
            const scoresHtml = playerScores
                .sort((a, b) => a.value - b.value)
                .map(player => `
                    <div class="score-row ${player.name === winner.name ? 'winner-row' : ''}">
                        <span>${player.name === winner.name ? '👑 ' : ''}${player.name}</span>
                        <span>${player.value} points</span>
                    </div>
                `).join('');
            
            document.getElementById('finalScores').innerHTML = scoresHtml;
            document.getElementById('gameOverModal').classList.add('active');
        }

        function showMatchAborted(leftPlayerName) {
            isInGame = false;
            localStorage.removeItem('yanivGameState');
            
            document.getElementById('leftPlayerName').textContent = leftPlayerName;
            document.getElementById('matchAbortedModal').classList.add('active');
            
            // Hide leave button
            document.getElementById('leaveBtn').classList.remove('active');
            
            // Clean up realtime subscription
            if (realtimeChannel) {
                realtimeChannel.unsubscribe();
            }
        }

        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(screenId).classList.add('active');
        }

        function showMessage(text, type) {
            const messageArea = document.getElementById('messageArea');
            const msgDiv = document.createElement('div');
            msgDiv.className = `message ${type}`;
            msgDiv.textContent = text;
            messageArea.innerHTML = '';
            messageArea.appendChild(msgDiv);
            setTimeout(() => msgDiv.remove(), 4000);
        }

        function showRules() {
            document.getElementById('rulesModal').classList.add('active');
        }

        function closeRules() {
            document.getElementById('rulesModal').classList.remove('active');
        }

        window.onclick = function(event) {
            const modal = document.getElementById('rulesModal');
            if (event.target === modal) {
                closeRules();
            }
        }
    </script>
</body>
</html>
